---
phase: 06-documentation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/native_routes/mod.rs
  - src/native_routes/docs.rs
  - src/routes/mod.rs
autonomous: true

must_haves:
  truths:
    - "GET /native/docs serves Swagger UI for interactive API exploration"
    - "GET /native/docs/openapi.json returns raw OpenAPI spec as JSON"
    - "Docs endpoints return 404 when X-Docs-Key header missing/invalid (prod mode)"
    - "Docs endpoints accessible without key when DOCS_API_KEY env var not set (dev mode)"
  artifacts:
    - path: "src/native_routes/docs.rs"
      provides: "Docs routes and API key middleware"
      contains: "docs_auth_middleware"
    - path: "src/routes/mod.rs"
      provides: "Docs router integration"
      contains: "native/docs"
  key_links:
    - from: "src/native_routes/docs.rs"
      to: "src/docs/openapi.rs"
      via: "NativeApiDoc import"
      pattern: "NativeApiDoc::openapi"
    - from: "src/routes/mod.rs"
      to: "src/native_routes/docs.rs"
      via: "router merge"
      pattern: "create_docs_router"
---

<objective>
Implement protected docs endpoints serving Swagger UI and raw OpenAPI JSON.

Purpose: Provide interactive API documentation for developers with API key protection to prevent public exposure of API details.

Output:
- Swagger UI at GET /native/docs
- Raw JSON at GET /native/docs/openapi.json
- X-Docs-Key middleware returning 404 on auth failure
- Dev-friendly mode (no key required when env var unset)
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-documentation/06-CONTEXT.md
@.planning/phases/06-documentation/06-RESEARCH.md
@.planning/phases/06-documentation/06-01-SUMMARY.md

Key files:
@src/native_routes/mod.rs
@src/routes/mod.rs
@src/docs/openapi.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docs routes with API key middleware</name>
  <files>
    - src/native_routes/docs.rs
    - src/native_routes/mod.rs
  </files>
  <action>
1. Create `src/native_routes/docs.rs`:
   ```rust
   //! Documentation endpoints for the Native API
   //!
   //! Serves Swagger UI and raw OpenAPI spec with API key protection.
   //! Protected by X-Docs-Key header; returns 404 when unauthorized to hide endpoint existence.

   use axum::{
       extract::Request,
       http::StatusCode,
       middleware::Next,
       response::{IntoResponse, Response},
       Router,
   };
   use utoipa::OpenApi;
   use utoipa_swagger_ui::SwaggerUi;

   use crate::docs::NativeApiDoc;

   /// Middleware to protect docs endpoints with API key
   ///
   /// Checks for X-Docs-Key header matching DOCS_API_KEY environment variable.
   /// Returns 404 (not 401/403) when unauthorized to hide endpoint existence.
   /// Allows access when DOCS_API_KEY is not set (dev mode).
   pub async fn docs_auth_middleware(
       request: Request,
       next: Next,
   ) -> Result<Response, Response> {
       // Get expected API key from environment
       let expected_key = std::env::var("DOCS_API_KEY").ok();

       // If no key configured, allow access (dev mode)
       if expected_key.is_none() {
           return Ok(next.run(request).await);
       }

       // Check X-Docs-Key header
       let provided_key = request
           .headers()
           .get("X-Docs-Key")
           .and_then(|v| v.to_str().ok());

       match (expected_key, provided_key) {
           (Some(expected), Some(provided)) if expected == provided => {
               Ok(next.run(request).await)
           }
           _ => {
               // Return 404 to hide endpoint existence
               Err(StatusCode::NOT_FOUND.into_response())
           }
       }
   }

   /// Create the docs router
   ///
   /// Routes:
   /// - GET /native/docs - Swagger UI
   /// - GET /native/docs/openapi.json - Raw OpenAPI spec
   ///
   /// IMPORTANT: This router should be merged WITHOUT the /native prefix,
   /// as SwaggerUi handles the full path internally.
   pub fn create_docs_router() -> Router {
       let openapi = NativeApiDoc::openapi();

       Router::new()
           .merge(
               SwaggerUi::new("/native/docs")
                   .url("/native/docs/openapi.json", openapi)
           )
           .layer(axum::middleware::from_fn(docs_auth_middleware))
   }
   ```

2. Update `src/native_routes/mod.rs`:
   - Add `pub mod docs;` declaration
   - Re-export: `pub use docs::create_docs_router;`
  </action>
  <verify>
    `cargo check` passes with new docs module
  </verify>
  <done>
    Docs routes created with API key middleware, returns 404 on auth failure
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire docs router into main application</name>
  <files>
    - src/routes/mod.rs
  </files>
  <action>
1. Update `src/routes/mod.rs`:
   - Import create_docs_router: `use crate::native_routes::create_docs_router;`
   - Merge docs router into the main router BEFORE the native router (to avoid middleware conflicts):
     ```rust
     // Docs router (no auth/rate-limit middleware, only API key protection)
     .merge(create_docs_router())
     ```
   - The docs router is merged at root level because SwaggerUi handles the /native/docs path internally
   - It must be merged WITHOUT the state and WITHOUT the auth middleware layer

IMPORTANT considerations:
- The docs router should NOT have the auth_middleware or rate_limit_middleware applied
- It uses its own docs_auth_middleware layer
- The merge should happen before any layers that would affect docs routes
- Check existing router structure and merge at appropriate location
  </action>
  <verify>
    `cargo check` passes with docs router integrated
  </verify>
  <done>
    Docs router merged into main application router
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for docs endpoints</name>
  <files>
    - src/native_routes/docs.rs
  </files>
  <action>
1. Add tests module to `src/native_routes/docs.rs`:
   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;
       use axum::{
           body::Body,
           http::{Request, StatusCode},
       };
       use tower::ServiceExt;

       // Test: Docs accessible without key when env var not set (dev mode)
       #[tokio::test]
       async fn test_docs_accessible_without_key_in_dev_mode() {
           // Ensure DOCS_API_KEY is not set
           std::env::remove_var("DOCS_API_KEY");

           let app = create_docs_router();

           // Request without X-Docs-Key header
           let request = Request::builder()
               .uri("/native/docs/openapi.json")
               .body(Body::empty())
               .unwrap();

           let response = app.oneshot(request).await.unwrap();

           // Should succeed in dev mode
           assert_eq!(response.status(), StatusCode::OK);
       }

       // Test: Docs return 404 without key when env var is set (prod mode)
       #[tokio::test]
       async fn test_docs_return_404_without_key_in_prod_mode() {
           std::env::set_var("DOCS_API_KEY", "secret-docs-key");

           let app = create_docs_router();

           // Request without X-Docs-Key header
           let request = Request::builder()
               .uri("/native/docs/openapi.json")
               .body(Body::empty())
               .unwrap();

           let response = app.oneshot(request).await.unwrap();

           // Should return 404 to hide endpoint
           assert_eq!(response.status(), StatusCode::NOT_FOUND);

           std::env::remove_var("DOCS_API_KEY");
       }

       // Test: Docs return 404 with wrong key (prod mode)
       #[tokio::test]
       async fn test_docs_return_404_with_wrong_key() {
           std::env::set_var("DOCS_API_KEY", "secret-docs-key");

           let app = create_docs_router();

           // Request with wrong X-Docs-Key header
           let request = Request::builder()
               .uri("/native/docs/openapi.json")
               .header("X-Docs-Key", "wrong-key")
               .body(Body::empty())
               .unwrap();

           let response = app.oneshot(request).await.unwrap();

           // Should return 404 to hide endpoint
           assert_eq!(response.status(), StatusCode::NOT_FOUND);

           std::env::remove_var("DOCS_API_KEY");
       }

       // Test: Docs accessible with correct key (prod mode)
       #[tokio::test]
       async fn test_docs_accessible_with_correct_key() {
           std::env::set_var("DOCS_API_KEY", "secret-docs-key");

           let app = create_docs_router();

           // Request with correct X-Docs-Key header
           let request = Request::builder()
               .uri("/native/docs/openapi.json")
               .header("X-Docs-Key", "secret-docs-key")
               .body(Body::empty())
               .unwrap();

           let response = app.oneshot(request).await.unwrap();

           // Should succeed with correct key
           assert_eq!(response.status(), StatusCode::OK);

           std::env::remove_var("DOCS_API_KEY");
       }

       // Test: OpenAPI JSON contains expected structure
       #[tokio::test]
       async fn test_openapi_json_structure() {
           std::env::remove_var("DOCS_API_KEY");

           let app = create_docs_router();

           let request = Request::builder()
               .uri("/native/docs/openapi.json")
               .body(Body::empty())
               .unwrap();

           let response = app.oneshot(request).await.unwrap();
           assert_eq!(response.status(), StatusCode::OK);

           let body = axum::body::to_bytes(response.into_body(), usize::MAX)
               .await
               .unwrap();
           let spec: serde_json::Value = serde_json::from_slice(&body).unwrap();

           // Verify OpenAPI structure
           assert_eq!(spec["openapi"].as_str().unwrap().starts_with("3."), true);
           assert!(spec["info"]["title"].as_str().unwrap().contains("Sentinel"));
           assert!(spec["paths"]["/native/v1/chat/completions"].is_object());
           assert!(spec["components"]["schemas"]["ChatCompletionRequest"].is_object());
           assert!(spec["components"]["securitySchemes"]["bearer_auth"].is_object());
       }
   }
   ```

Note: Tests may need to be marked as `#[ignore]` or run with `--test-threads=1` due to env var manipulation. Alternatively, use a test setup that doesn't conflict.
  </action>
  <verify>
    `cargo test docs` passes (or `cargo test -- --test-threads=1` if env var conflicts)
  </verify>
  <done>
    Tests verify API key protection and OpenAPI spec structure
  </done>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes with docs integration
- [ ] `cargo test` passes (including docs tests)
- [ ] With DOCS_API_KEY unset: `curl http://localhost:8080/native/docs/openapi.json` returns JSON
- [ ] With DOCS_API_KEY unset: `curl http://localhost:8080/native/docs` serves Swagger UI
- [ ] With DOCS_API_KEY=secret: `curl http://localhost:8080/native/docs/openapi.json` returns 404
- [ ] With DOCS_API_KEY=secret: `curl -H "X-Docs-Key: secret" http://localhost:8080/native/docs/openapi.json` returns JSON
</verification>

<success_criteria>
- Swagger UI accessible at /native/docs
- Raw OpenAPI JSON at /native/docs/openapi.json
- X-Docs-Key middleware returns 404 on unauthorized access
- Dev mode works without DOCS_API_KEY set
- Tests cover all auth scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/06-documentation/06-02-SUMMARY.md`
</output>
