---
phase: 06-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/native/types.rs
  - src/native/request.rs
  - src/native/response.rs
  - src/native/error.rs
  - src/native/mod.rs
  - src/native_routes/chat.rs
  - src/docs/mod.rs
  - src/docs/openapi.rs
  - src/lib.rs
  - src/bin/export_openapi.rs
autonomous: true

must_haves:
  truths:
    - "All native types have ToSchema derive for OpenAPI documentation"
    - "Chat handler has utoipa::path annotation describing endpoint"
    - "OpenApi struct aggregates all schemas and paths"
    - "Static export binary generates docs/openapi.json"
  artifacts:
    - path: "src/docs/mod.rs"
      provides: "Docs module declaration"
      exports: ["NativeApiDoc"]
    - path: "src/docs/openapi.rs"
      provides: "OpenAPI struct with security schemes"
      contains: "struct NativeApiDoc"
    - path: "src/bin/export_openapi.rs"
      provides: "Binary for static spec generation"
      contains: "fn main()"
  key_links:
    - from: "src/docs/openapi.rs"
      to: "src/native_routes/chat.rs"
      via: "paths() attribute"
      pattern: "native_routes::chat::native_chat_completions"
    - from: "src/docs/openapi.rs"
      to: "src/native/types.rs"
      via: "components(schemas()) attribute"
      pattern: "schemas\\("
---

<objective>
Implement OpenAPI specification generation using utoipa for the Native API.

Purpose: Enable automatic, code-synchronized API documentation that can be served to clients and used for SDK generation. This is the foundation for the docs endpoint in Plan 02.

Output:
- utoipa dependencies in Cargo.toml
- ToSchema derives on all native types
- utoipa::path annotation on chat handler
- NativeApiDoc struct with security schemes
- Static export binary for CI/tooling
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-documentation/06-CONTEXT.md
@.planning/phases/06-documentation/06-RESEARCH.md

Key files to modify:
@src/native/types.rs
@src/native/request.rs
@src/native/response.rs
@src/native/error.rs
@src/native_routes/chat.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add utoipa dependencies and create docs module</name>
  <files>
    - Cargo.toml
    - src/docs/mod.rs
    - src/docs/openapi.rs
    - src/lib.rs
  </files>
  <action>
1. Add utoipa dependencies to Cargo.toml:
   ```toml
   utoipa = { version = "5.4", features = ["axum_extras"] }
   utoipa-swagger-ui = { version = "9.0", features = ["axum", "vendored"] }
   ```

2. Create `src/docs/mod.rs`:
   - Declare openapi submodule
   - Re-export NativeApiDoc

3. Create `src/docs/openapi.rs`:
   - Import utoipa::{openapi::security::{Http, HttpAuthScheme, SecurityScheme}, Modify, OpenApi}
   - Define NativeApiDoc struct with #[derive(OpenApi)]
   - Include openapi() attribute with:
     - info(title = "Sentinel Native API", version = "1.0.0", description = "Native API for Sentinel AI Proxy - unified format with tier routing and session management")
     - paths() - leave empty for now, will add handler in Task 2
     - components(schemas()) - leave empty for now, populated in Task 2
     - modifiers(&SecurityAddon)
     - tags((name = "Chat", description = "Chat completion endpoints"))
   - Implement SecurityAddon struct with Modify trait:
     - Add "bearer_auth" security scheme: Http Bearer with JWT format
     - Description: "Zion JWT token in Authorization header"

4. Update `src/lib.rs`:
   - Add `pub mod docs;` declaration
  </action>
  <verify>
    `cargo check` passes with new dependencies and module structure
  </verify>
  <done>
    utoipa dependencies added, docs module created with NativeApiDoc stub
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ToSchema derives to all native types</name>
  <files>
    - src/native/types.rs
    - src/native/request.rs
    - src/native/response.rs
    - src/native/error.rs
    - src/native/mod.rs
    - src/docs/openapi.rs
  </files>
  <action>
1. Update `src/native/types.rs`:
   - Add `use utoipa::ToSchema;`
   - Add `#[derive(ToSchema)]` to: Role, ImageUrl, ContentPart, Content, Message, Tier, FunctionDefinition, ToolDefinition, ToolCallFunction, ToolCall, ToolResultContent, ToolResult, ToolChoice
   - Add doc comments and #[schema(example = "...")] attributes for key fields:
     - Role: example for each variant
     - Tier: examples "simple", "moderate", "complex"
     - Message.content: example "Hello, how can I help you today?"
     - ToolCall.id: example "call_abc123xyz"
   - For ToolChoice and ToolResultContent (custom serde): may need manual ToSchema impl or accept generated schema

2. Update `src/native/request.rs`:
   - Add `use utoipa::ToSchema;`
   - Add `#[derive(ToSchema)]` to: StopSequence, ChatCompletionRequest
   - Add schema examples:
     - tier: example = "simple"
     - temperature: minimum = 0.0, maximum = 2.0, example = 0.7
     - max_tokens: minimum = 1, example = 1000
     - conversation_id: example = "conv-550e8400-e29b-41d4-a716-446655440000"

3. Update `src/native/response.rs`:
   - Add `use utoipa::ToSchema;`
   - Add `#[derive(ToSchema)]` to: Usage, ChoiceMessage, Choice, ChatCompletionResponse, ToolCallFunctionDelta, ToolCallDelta, Delta, StreamChoice, StreamChunk
   - Add examples for key fields:
     - Usage.prompt_tokens: example = 50
     - Usage.completion_tokens: example = 100
     - ChatCompletionResponse.id: example = "chatcmpl-abc123"
     - ChatCompletionResponse.model: example = "gpt-4o-mini"

4. Update `src/native/error.rs`:
   - Add `use utoipa::ToSchema;`
   - Add `#[derive(ToSchema)]` to: NativeError, NativeErrorResponse
   - Note: RateLimitInfo is not serialized, skip it
   - Add examples:
     - NativeError.message: example = "Invalid request body: missing required field 'messages'"
     - NativeError.error_type: example = "invalid_request_error"
     - NativeError.code: example = "invalid_request"
     - NativeError.provider: example = "openai"

5. Update `src/docs/openapi.rs`:
   - Import all native types in components(schemas()):
     - From types: Role, ImageUrl, ContentPart, Content, Message, Tier, FunctionDefinition, ToolDefinition, ToolCallFunction, ToolCall, ToolResultContent, ToolResult, ToolChoice
     - From request: StopSequence, ChatCompletionRequest
     - From response: Usage, ChoiceMessage, Choice, ChatCompletionResponse, ToolCallFunctionDelta, ToolCallDelta, Delta, StreamChoice, StreamChunk
     - From error: NativeError, NativeErrorResponse
  </action>
  <verify>
    `cargo check` passes with all ToSchema derives
  </verify>
  <done>
    All native types have ToSchema derives with realistic examples
  </done>
</task>

<task type="auto">
  <name>Task 3: Add utoipa::path to chat handler and create export binary</name>
  <files>
    - src/native_routes/chat.rs
    - src/docs/openapi.rs
    - src/bin/export_openapi.rs
  </files>
  <action>
1. Update `src/native_routes/chat.rs`:
   - Add `use utoipa::path;` (or just reference as `#[utoipa::path(...)]`)
   - Add comprehensive #[utoipa::path] annotation to native_chat_completions handler:
     ```rust
     #[utoipa::path(
         post,
         path = "/native/v1/chat/completions",
         tag = "Chat",
         operation_id = "createNativeChatCompletion",
         request_body(
             content = ChatCompletionRequest,
             description = "Chat completion request with messages, tier, and optional settings",
             content_type = "application/json"
         ),
         responses(
             (status = 200, description = "Successful completion", body = ChatCompletionResponse,
                 content_type = "application/json"),
             (status = 200, description = "Streaming completion (when stream=true)",
                 content_type = "text/event-stream",
                 body = String,
                 example = json!("data: {\"id\":\"chatcmpl-123\",\"object\":\"chat.completion.chunk\",...}\n\ndata: [DONE]\n\n")),
             (status = 400, description = "Invalid request - malformed JSON or validation error", body = NativeErrorResponse,
                 example = json!({"error": {"message": "Invalid request body: unknown field `model`", "type": "invalid_request_error", "code": "invalid_request"}})),
             (status = 401, description = "Missing or invalid JWT in Authorization header"),
             (status = 403, description = "Insufficient permissions or quota exceeded"),
             (status = 429, description = "Rate limit exceeded", body = NativeErrorResponse,
                 example = json!({"error": {"message": "Rate limit exceeded", "type": "rate_limit_error", "code": "rate_limit_exceeded"}})),
             (status = 500, description = "Internal server error", body = NativeErrorResponse),
             (status = 502, description = "Provider error - upstream AI provider failed", body = NativeErrorResponse,
                 example = json!({"error": {"message": "Model overloaded", "type": "upstream_error", "code": "provider_error", "provider": "openai"}})),
             (status = 503, description = "Service unavailable - no healthy providers", body = NativeErrorResponse,
                 example = json!({"error": {"message": "No available models for tier", "type": "service_unavailable", "code": "service_unavailable"}}))
         ),
         security(
             ("bearer_auth" = [])
         )
     )]
     pub async fn native_chat_completions(
     ```

2. Update `src/docs/openapi.rs`:
   - Add the handler path to the paths() attribute:
     ```rust
     paths(
         crate::native_routes::chat::native_chat_completions
     ),
     ```

3. Create `src/bin/export_openapi.rs`:
   ```rust
   //! Export OpenAPI specification to static JSON file
   //!
   //! Usage: cargo run --bin export_openapi
   //!
   //! Generates docs/openapi.json for SDK generation and API linting.

   use sentinel::docs::NativeApiDoc;
   use utoipa::OpenApi;
   use std::fs;

   fn main() {
       let spec = NativeApiDoc::openapi();
       let json = spec.to_pretty_json().expect("Failed to serialize OpenAPI spec");

       // Ensure docs directory exists
       fs::create_dir_all("docs").expect("Failed to create docs directory");

       fs::write("docs/openapi.json", json).expect("Failed to write openapi.json");
       println!("Exported OpenAPI spec to docs/openapi.json");
   }
   ```

4. Add binary declaration to Cargo.toml:
   ```toml
   [[bin]]
   name = "export_openapi"
   path = "src/bin/export_openapi.rs"
   ```
  </action>
  <verify>
    - `cargo check` passes
    - `cargo run --bin export_openapi` succeeds and creates docs/openapi.json
    - `cat docs/openapi.json | head -50` shows valid OpenAPI structure with paths and schemas
  </verify>
  <done>
    Chat handler documented with utoipa::path, export binary creates valid OpenAPI spec
  </done>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes with all utoipa annotations
- [ ] `cargo test` passes (existing tests unaffected)
- [ ] `cargo run --bin export_openapi` creates docs/openapi.json
- [ ] OpenAPI spec contains `/native/v1/chat/completions` path
- [ ] OpenAPI spec contains all schema definitions (ChatCompletionRequest, etc.)
- [ ] OpenAPI spec includes bearer_auth security scheme
</verification>

<success_criteria>
- utoipa 5.x dependencies in Cargo.toml
- All native types have ToSchema derive with examples
- Chat handler has comprehensive utoipa::path annotation
- NativeApiDoc struct aggregates paths and schemas
- Static export binary generates valid OpenAPI 3.x JSON
</success_criteria>

<output>
After completion, create `.planning/phases/06-documentation/06-01-SUMMARY.md`
</output>
