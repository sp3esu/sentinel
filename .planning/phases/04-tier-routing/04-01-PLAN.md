---
phase: 04-tier-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/native/types.rs
  - src/native/request.rs
  - src/zion/models.rs
autonomous: true

must_haves:
  truths:
    - "Tier enum has Simple, Moderate, Complex variants with ordering (PartialOrd)"
    - "ChatCompletionRequest has tier field instead of model field"
    - "TierConfigData can deserialize from Zion API response"
  artifacts:
    - path: "src/native/types.rs"
      provides: "Tier enum"
      exports: ["Tier"]
    - path: "src/native/request.rs"
      provides: "tier field on ChatCompletionRequest"
      contains: "pub tier:"
    - path: "src/zion/models.rs"
      provides: "Tier config types from Zion"
      exports: ["TierConfigResponse", "TierConfigData", "TierMapping", "ModelConfig"]
  key_links:
    - from: "src/native/request.rs"
      to: "src/native/types.rs"
      via: "Tier enum import"
      pattern: "use.*Tier"
---

<objective>
Create the tier routing foundation types: Tier enum and tier configuration data types.

Purpose: Establish the core data structures that Plan 01b (Zion integration) and Plan 02 (model selection) will use. The `model` field is replaced with `tier` field in the request.

Output: Tier enum with ordering, updated ChatCompletionRequest, Zion tier config types.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tier-routing/04-CONTEXT.md
@.planning/phases/04-tier-routing/04-RESEARCH.md

@src/native/types.rs
@src/native/request.rs
@src/zion/models.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tier enum to native types</name>
  <files>src/native/types.rs</files>
  <action>
Add the Tier enum to `src/native/types.rs`:

```rust
/// Complexity tier for model routing
///
/// Ordered from lowest to highest complexity for upgrade comparison.
/// Implements PartialOrd so tiers can be compared: Simple < Moderate < Complex.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize, Hash)]
#[serde(rename_all = "snake_case")]
pub enum Tier {
    /// Simple tasks - fast, cheap models (e.g., gpt-4o-mini)
    Simple,
    /// Moderate tasks - balanced models (e.g., gpt-4o)
    Moderate,
    /// Complex tasks - most capable models (e.g., gpt-4o)
    Complex,
}

impl Default for Tier {
    fn default() -> Self {
        Tier::Simple
    }
}

impl std::fmt::Display for Tier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Tier::Simple => write!(f, "simple"),
            Tier::Moderate => write!(f, "moderate"),
            Tier::Complex => write!(f, "complex"),
        }
    }
}

impl Tier {
    /// Check if upgrading from current tier to new tier is allowed.
    ///
    /// Upgrades: simple -> moderate -> complex allowed.
    /// Downgrades: not allowed within session.
    pub fn can_upgrade_to(&self, new_tier: &Tier) -> bool {
        new_tier >= self
    }
}
```

Add unit tests:
1. Test serialization to snake_case ("simple", "moderate", "complex")
2. Test default is Simple
3. Test ordering: Simple < Moderate < Complex
4. Test can_upgrade_to logic (upgrades allowed, downgrades not)
5. Test Display trait
  </action>
  <verify>
`cargo check` passes.
`cargo test native::types::tests` passes with Tier tests.
  </verify>
  <done>
Tier enum is defined with ordering and serialization.
can_upgrade_to method allows upgrades only.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace model with tier in ChatCompletionRequest</name>
  <files>src/native/request.rs</files>
  <action>
Modify `ChatCompletionRequest` in `src/native/request.rs`:

1. Add import for Tier:
   ```rust
   use super::types::Tier;
   ```

2. Replace the `model` field with `tier` field:
   ```rust
   /// Complexity tier for model routing (optional, defaults to simple)
   ///
   /// Controls which model is selected for this request:
   /// - `simple`: Fast, cost-effective models for straightforward tasks
   /// - `moderate`: Balanced models for typical assistant interactions
   /// - `complex`: Most capable models for difficult reasoning tasks
   #[serde(skip_serializing_if = "Option::is_none")]
   pub tier: Option<Tier>,
   ```

   REMOVE the existing `model: Option<String>` field.

3. Update all tests that reference `model` to use `tier` instead:
   - Update test JSON to use `"tier": "simple"` instead of `"model": "gpt-4"`
   - Update assertions to check `request.tier`
   - Test that tier defaults to None (caller defaults to Simple)
   - Test that unknown tier values fail validation (serde rejects "invalid")

4. Add tests for tier serialization:
   - `test_tier_simple_deserializes`
   - `test_tier_moderate_deserializes`
   - `test_tier_complex_deserializes`
   - `test_tier_invalid_rejected`
   - `test_tier_optional_defaults_to_none`
  </action>
  <verify>
`cargo test native::request::tests` passes with updated tier tests.
`cargo check` passes (expect errors from other files - addressed in Plan 03).
  </verify>
  <done>
ChatCompletionRequest uses tier field instead of model.
tier is optional, defaulting to None (Simple at handler level).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tier config types to Zion models</name>
  <files>src/zion/models.rs</files>
  <action>
Add tier configuration types to `src/zion/models.rs`:

```rust
// ===========================================
// Tier Configuration Types
// ===========================================

/// Model configuration for a single provider/model combination
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct ModelConfig {
    /// Provider name (e.g., "openai", "anthropic")
    pub provider: String,
    /// Model identifier (e.g., "gpt-4o-mini", "gpt-4o")
    pub model: String,
    /// Relative cost score (1-10, lower is cheaper)
    /// Used for weighted selection - lower cost = higher probability
    pub relative_cost: u8,
    /// Input token price per million (for cost reporting)
    pub input_price_per_million: f64,
    /// Output token price per million (for cost reporting)
    pub output_price_per_million: f64,
}

/// Tier-to-model mapping configuration
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct TierMapping {
    /// Models available for simple tier
    pub simple: Vec<ModelConfig>,
    /// Models available for moderate tier
    pub moderate: Vec<ModelConfig>,
    /// Models available for complex tier
    pub complex: Vec<ModelConfig>,
}

/// Tier configuration data from Zion
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct TierConfigData {
    /// Config version for cache invalidation
    pub version: String,
    /// When this config was last updated
    pub updated_at: String,
    /// Tier-to-model mappings
    pub tiers: TierMapping,
}

/// Response wrapper from tier config endpoint
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TierConfigResponse {
    pub success: bool,
    pub data: TierConfigData,
}
```

Add unit tests:
1. Test ModelConfig serialization round-trip
2. Test TierConfigData deserialization from example JSON
3. Test that relative_cost validation (must be >= 1) - document this constraint
  </action>
  <verify>
`cargo test zion::models::tests` passes with new tier config tests.
`cargo check` passes.
  </verify>
  <done>
Tier config types are defined matching expected Zion API response.
All types derive necessary traits for caching (Serialize, Deserialize, Clone).
  </done>
</task>

</tasks>

<verification>
1. `cargo check` - No compilation errors (expect warnings about unused code until Plan 01b)
2. `cargo test native::types::tests` - Tier enum tests pass
3. `cargo test native::request::tests` - Updated request tests pass with tier field
4. `cargo test zion::models::tests` - Tier config type tests pass
</verification>

<success_criteria>
- Tier enum has Simple, Moderate, Complex with ordering
- ChatCompletionRequest has tier field instead of model
- TierConfigData can deserialize from expected JSON format
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-tier-routing/04-01-SUMMARY.md`
</output>
