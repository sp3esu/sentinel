---
phase: 01-types-and-translation
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/native/error.rs
  - src/native/translate/anthropic.rs
  - src/native/translate/mod.rs
  - src/native/mod.rs
autonomous: true

must_haves:
  truths:
    - "Unified error response matches OpenAI error format structure"
    - "Provider errors are wrapped with provider hint (not raw pass-through)"
    - "Rate limit errors include Retry-After information"
    - "Anthropic alternation validation rejects consecutive same-role messages"
  artifacts:
    - path: "src/native/error.rs"
      provides: "NativeError types with OpenAI-compatible format"
      contains: "pub struct NativeErrorResponse"
    - path: "src/native/translate/anthropic.rs"
      provides: "Anthropic translator scaffold with alternation validation"
      contains: "validate_anthropic_alternation"
  key_links:
    - from: "src/native/error.rs"
      to: "axum IntoResponse"
      via: "impl IntoResponse"
      pattern: "impl IntoResponse for NativeErrorResponse"
---

<objective>
Implement unified error handling and scaffold the Anthropic translator with alternation validation.

Purpose: Ensure all errors from the Native API return in a consistent OpenAI-compatible format. The Anthropic translator scaffold validates the type design for strict alternation requirements, even though the provider won't be wired until v2.

Output: A `error.rs` module with unified error types and an `anthropic.rs` translator with validation logic.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-types-and-translation/01-CONTEXT.md
@.planning/phases/01-types-and-translation/01-RESEARCH.md
@.planning/phases/01-types-and-translation/01-01-SUMMARY.md
@src/native/types.rs
@src/native/translate/mod.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unified error types</name>
  <files>src/native/error.rs, src/native/mod.rs</files>
  <action>
1. Create `src/native/error.rs` with:

   `NativeError` struct:
   - `message: String`
   - `error_type: String` (serialized as "type")
   - `code: String`
   - `provider: Option<String>` (skip_serializing_if None)

   `NativeErrorResponse` struct:
   - `error: NativeError`

   Factory methods on `NativeErrorResponse`:
   - `validation(message: impl Into<String>) -> Self` - type: "invalid_request_error", code: "invalid_request"
   - `provider_error(message: impl Into<String>, provider: &str) -> Self` - type: "upstream_error", code: "provider_error"
   - `rate_limited(message: impl Into<String>, retry_after: Option<u64>) -> Self` - type: "rate_limit_error", code: "rate_limit_exceeded"
   - `internal(message: impl Into<String>) -> Self` - type: "server_error", code: "internal_error"

   `RateLimitInfo` struct for rate limit details:
   - `retry_after: Option<u64>` - seconds until retry allowed

   Implement `IntoResponse for NativeErrorResponse`:
   - validation errors -> 400
   - provider_error -> 502
   - rate_limited -> 429 with Retry-After header
   - internal -> 500

2. Update `src/native/mod.rs` to add `pub mod error;`
  </action>
  <verify>
`cargo check` passes with error types defined
  </verify>
  <done>
NativeErrorResponse implements IntoResponse with correct HTTP status codes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Anthropic translator scaffold</name>
  <files>src/native/translate/anthropic.rs, src/native/translate/mod.rs</files>
  <action>
1. Create `src/native/translate/anthropic.rs` with:

   `AnthropicTranslator` struct (unit struct)

   `validate_anthropic_alternation(messages: &[Message]) -> Result<(), TranslationError>`:
   - Filter out system messages (they go to separate field for Anthropic)
   - Check non-system messages is not empty (NoUserMessage error)
   - Check first non-system is User role (FirstMustBeUser error)
   - Check strict alternation user/assistant (MustAlternate error)
   - Return Ok(()) if valid

   `extract_system_prompt(messages: &[Message]) -> (Option<String>, Vec<&Message>)`:
   - Find system messages (must be at start per our validation)
   - Extract text content, concatenate if multiple
   - Return remaining messages (non-system)
   - Note: validate_message_order from OpenAI translator ensures system is first

   Add to `TranslationError` enum in mod.rs:
   - `NoUserMessage`
   - `FirstMustBeUser`
   - `MustAlternate`

   Implement `MessageTranslator` for `AnthropicTranslator`:
   - `translate_request`: Call validation, return `Err(TranslationError::NotImplemented)` for actual translation
   - `translate_response`: Return `Err(TranslationError::NotImplemented)`
   - `translate_stop_reason`: Map Anthropic reasons to unified format:
     - "end_turn" -> "stop"
     - "max_tokens" -> "length"
     - "stop_sequence" -> "stop"
     - "tool_use" -> "tool_calls"
     - _ -> "stop"

   Add `NotImplemented` variant to TranslationError for scaffold methods.

2. Update `src/native/translate/mod.rs` to add `pub mod anthropic;`
  </action>
  <verify>
`cargo check` passes with Anthropic translator scaffold
  </verify>
  <done>
Anthropic alternation validation exists and catches invalid message sequences
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error and Anthropic tests</name>
  <files>src/native/error.rs, src/native/translate/anthropic.rs</files>
  <action>
Add `#[cfg(test)] mod tests` to each file:

In `error.rs`:
1. `test_validation_error_json`:
   - Create validation error
   - Serialize to JSON
   - Verify structure: `{"error": {"message": "...", "type": "invalid_request_error", "code": "invalid_request"}}`

2. `test_provider_error_includes_hint`:
   - Create provider_error with "openai"
   - Serialize to JSON
   - Verify "provider": "openai" is present

3. `test_rate_limit_error_status`:
   - Create rate_limited error
   - Call into_response()
   - Verify status is 429

In `anthropic.rs`:
4. `test_alternation_valid`:
   - Messages: [system, user, assistant, user]
   - validate_anthropic_alternation returns Ok

5. `test_consecutive_user_rejected`:
   - Messages: [user, user]
   - Returns MustAlternate error

6. `test_first_must_be_user`:
   - Messages: [assistant, user]
   - Returns FirstMustBeUser error

7. `test_extract_system_prompt`:
   - Messages: [system("Hello"), user("Hi")]
   - Returns (Some("Hello"), [user("Hi")])

8. `test_stop_reason_mapping`:
   - "end_turn" -> "stop"
   - "max_tokens" -> "length"
   - "tool_use" -> "tool_calls"
  </action>
  <verify>
`cargo test native::error` and `cargo test translate::anthropic` pass
  </verify>
  <done>
At least 8 tests covering error formatting and Anthropic validation
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check` - no errors in error or anthropic modules
2. `cargo test native::` - all tests pass
3. Verify: Error JSON matches OpenAI error structure
4. Verify: Consecutive user messages fail Anthropic validation
5. Verify: System prompt extraction works correctly
6. Verify: Stop reason mapping covers Anthropic values
</verification>

<success_criteria>
- Error module provides OpenAI-compatible error responses
- Error types implement IntoResponse with correct HTTP status codes
- Anthropic translator validates strict alternation requirements
- Stop reason translation maps Anthropic reasons to unified format
- Unit tests verify error formatting and validation logic
</success_criteria>

<output>
After completion, create `.planning/phases/01-types-and-translation/01-04-SUMMARY.md`
</output>
