---
phase: 01-types-and-translation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/native/mod.rs
  - src/native/types.rs
  - src/native/request.rs
  - src/native/response.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Native API types serialize to OpenAI-compatible JSON format"
    - "Messages with role + content deserialize correctly"
    - "Unknown fields in requests cause deserialization errors"
    - "Optional parameters (temperature, max_tokens, top_p, stop) are supported"
  artifacts:
    - path: "src/native/mod.rs"
      provides: "Module exports for native API types"
      exports: ["types", "request", "response"]
    - path: "src/native/types.rs"
      provides: "Core message types (Role, Content, ContentPart, Message)"
      contains: "pub enum Role"
    - path: "src/native/request.rs"
      provides: "ChatCompletionRequest with strict validation"
      contains: "deny_unknown_fields"
    - path: "src/native/response.rs"
      provides: "ChatCompletionResponse and streaming chunk types"
      contains: "pub struct StreamChunk"
  key_links:
    - from: "src/lib.rs"
      to: "src/native/mod.rs"
      via: "pub mod native"
      pattern: "pub mod native"
---

<objective>
Define unified message types for the Native API that serialize to OpenAI-compatible JSON format.

Purpose: Establish the canonical message format that all providers translate to/from. This is the foundation for all translation and streaming work in subsequent plans.

Output: A `src/native/` module with types for messages, requests, and responses that can be serialized/deserialized with strict validation.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-types-and-translation/01-CONTEXT.md
@.planning/phases/01-types-and-translation/01-RESEARCH.md
@src/error.rs
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create native module with core message types</name>
  <files>src/native/mod.rs, src/native/types.rs</files>
  <action>
Create the native module structure:

1. Create `src/native/mod.rs` exporting submodules:
   - `pub mod types;`
   - `pub mod request;`
   - `pub mod response;`
   - Re-export key types for convenience

2. Create `src/native/types.rs` with:
   - `Role` enum: `System`, `User`, `Assistant`, `Tool` with `#[serde(rename_all = "lowercase")]`
   - `Content` enum (untagged): `Text(String)` and `Parts(Vec<ContentPart>)` for multimodal support
   - `ContentPart` enum (tagged by "type"): `Text { text: String }` and `ImageUrl { image_url: ImageUrl }`
   - `ImageUrl` struct with `url: String` and optional `detail: Option<String>`
   - `Message` struct with:
     - `role: Role`
     - `content: Content`
     - `name: Option<String>` (skip_serializing_if None)
     - `tool_call_id: Option<String>` (skip_serializing_if None)
   - Implement `Content::as_text()` helper method to extract text from either variant

Use `#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]` for all types.
  </action>
  <verify>
`cargo check` passes with no errors in native module
  </verify>
  <done>
Role, Content, ContentPart, Message types exist with correct serde attributes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create request and response types</name>
  <files>src/native/request.rs, src/native/response.rs, src/lib.rs</files>
  <action>
1. Create `src/native/request.rs` with:
   - `StopSequence` enum (untagged): `Single(String)` and `Multiple(Vec<String>)`
   - `ChatCompletionRequest` struct with `#[serde(deny_unknown_fields)]`:
     - `model: Option<String>` (optional - tier routing may override)
     - `messages: Vec<Message>`
     - `temperature: Option<f64>`
     - `max_tokens: Option<u32>`
     - `top_p: Option<f64>`
     - `stop: Option<StopSequence>`
     - `stream: bool` with `#[serde(default)]`
   - Explicitly list ALL supported fields - no flatten (incompatible with deny_unknown_fields)

2. Create `src/native/response.rs` with:
   - `Usage` struct: `prompt_tokens`, `completion_tokens`, `total_tokens` (all u32)
   - `ChoiceMessage` struct: `role: Role`, `content: Option<String>`
   - `Choice` struct: `index: u32`, `message: ChoiceMessage`, `finish_reason: Option<String>`
   - `ChatCompletionResponse` struct: `id`, `object`, `created`, `model`, `choices`, `usage`
   - `Delta` struct for streaming: `role: Option<Role>`, `content: Option<String>`
   - `StreamChoice` struct: `index: u32`, `delta: Delta`, `finish_reason: Option<String>`
   - `StreamChunk` struct: `id`, `object`, `created`, `model`, `choices: Vec<StreamChoice>`, `usage: Option<Usage>`

3. Update `src/lib.rs` to add `pub mod native;`

All types should use skip_serializing_if for optional fields.
  </action>
  <verify>
`cargo check` passes and `cargo test` passes
  </verify>
  <done>
Request types reject unknown fields; response types match OpenAI format
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for serialization</name>
  <files>src/native/types.rs, src/native/request.rs</files>
  <action>
Add `#[cfg(test)] mod tests` to each file:

In `types.rs`:
- Test Role serializes to lowercase: `Role::User` -> `"user"`
- Test Content::Text serializes as string directly
- Test Content::Parts serializes as array
- Test Message roundtrip serialization

In `request.rs`:
- Test valid request deserializes correctly
- Test unknown field causes deserialization error
- Test optional fields default correctly (stream defaults to false)
- Test StopSequence handles both single string and array

Example test:
```rust
#[test]
fn test_unknown_field_rejected() {
    let json = r#"{"messages": [], "unknown_field": true}"#;
    let result: Result<ChatCompletionRequest, _> = serde_json::from_str(json);
    assert!(result.is_err());
}
```
  </action>
  <verify>
`cargo test native::` passes with all tests green
  </verify>
  <done>
At least 6 unit tests covering serialization, unknown field rejection, and defaults
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check` - no errors or warnings in native module
2. `cargo test native::` - all tests pass
3. `cargo doc --no-deps` - types are documented
4. Verify: `ChatCompletionRequest` with unknown field fails to deserialize
5. Verify: `Message` with role "user" and string content serializes correctly
</verification>

<success_criteria>
- Native module exists at `src/native/` with types, request, response submodules
- All types derive Serialize, Deserialize with correct attributes
- `deny_unknown_fields` enforced on ChatCompletionRequest
- Unit tests verify serialization behavior
- Code compiles with `cargo check` and tests pass with `cargo test`
</success_criteria>

<output>
After completion, create `.planning/phases/01-types-and-translation/01-01-SUMMARY.md`
</output>
