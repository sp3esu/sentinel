---
phase: 01-types-and-translation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/native/streaming.rs
  - src/native/mod.rs
autonomous: true

must_haves:
  truths:
    - "Streaming chunks emit in OpenAI-compatible SSE format"
    - "Final chunk includes usage statistics when available"
    - "Chunk metadata (id, model) persists across all chunks"
    - "Stream terminates with [DONE] marker"
  artifacts:
    - path: "src/native/streaming.rs"
      provides: "Stream chunk normalization and SSE formatting"
      contains: "pub fn format_sse_chunk"
  key_links:
    - from: "src/native/streaming.rs"
      to: "src/native/response.rs"
      via: "StreamChunk type"
      pattern: "use.*response::StreamChunk"
---

<objective>
Implement streaming chunk normalization for the Native API.

Purpose: Ensure all streaming responses emit in a consistent OpenAI-compatible SSE format, regardless of which provider generated them. This plan focuses on the normalization layer; actual provider-specific parsing is deferred to when providers are wired.

Output: A `streaming.rs` module with utilities for formatting normalized stream chunks as SSE.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-types-and-translation/01-CONTEXT.md
@.planning/phases/01-types-and-translation/01-RESEARCH.md
@.planning/phases/01-types-and-translation/01-01-SUMMARY.md
@src/native/response.rs
@src/streaming/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create streaming normalization module</name>
  <files>src/native/streaming.rs, src/native/mod.rs</files>
  <action>
1. Create `src/native/streaming.rs` with:

   `StreamMetadata` struct to cache across chunks:
   - `id: String` - message/completion ID
   - `model: String` - model name
   - `created: i64` - Unix timestamp

   `format_sse_chunk(chunk: &StreamChunk) -> bytes::Bytes`:
   - Serialize chunk to JSON
   - Format as `data: {json}\n\n`
   - Return as Bytes

   `format_sse_done() -> bytes::Bytes`:
   - Return `data: [DONE]\n\n` as Bytes

   `StreamState` struct for accumulating stream state:
   - `metadata: Option<StreamMetadata>` - cached from first chunk
   - `accumulated_content: String` - for token counting fallback
   - Methods:
     - `new() -> Self`
     - `set_metadata(&mut self, meta: StreamMetadata)`
     - `append_content(&mut self, content: &str)`
     - `get_content(&self) -> &str`

   `create_chunk_with_metadata(metadata: &StreamMetadata, delta: Delta, finish_reason: Option<String>, usage: Option<Usage>) -> StreamChunk`:
   - Factory function to create StreamChunk with consistent metadata
   - Sets `object: "chat.completion.chunk"`
   - Includes single choice with index 0

2. Update `src/native/mod.rs` to add `pub mod streaming;`
  </action>
  <verify>
`cargo check` passes with streaming module defined
  </verify>
  <done>
Streaming module provides SSE formatting and metadata caching utilities
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stream normalization helpers</name>
  <files>src/native/streaming.rs</files>
  <action>
Add additional helpers for stream processing:

1. `NormalizedChunk` enum:
   ```rust
   pub enum NormalizedChunk {
       /// Content delta (text being generated)
       Delta(StreamChunk),
       /// Stream complete with optional usage
       Done(Option<Usage>),
       /// Keep-alive comment (no data)
       KeepAlive,
   }
   ```

2. `format_normalized(chunk: &NormalizedChunk) -> bytes::Bytes`:
   - `Delta(sc)` -> `format_sse_chunk(sc)`
   - `Done(_)` -> `format_sse_done()`
   - `KeepAlive` -> `: keep-alive\n\n` (SSE comment)

3. `StreamError` enum with thiserror:
   - `ParseError(String)` - Failed to parse provider chunk
   - `ConnectionClosed` - Stream closed unexpectedly
   - `ProviderError { message: String, code: Option<String> }` - Provider returned error in stream

4. `format_error_chunk(error: &StreamError) -> bytes::Bytes`:
   - Create error event for stream: `data: {"error": {"message": "...", "type": "stream_error"}}\n\n`
   - Note: Per CONTEXT.md, Claude's discretion on whether to emit error chunk before close - we choose to emit it
  </action>
  <verify>
`cargo check` passes with all helpers defined
  </verify>
  <done>
NormalizedChunk enum and format helpers handle all stream event types
  </done>
</task>

<task type="auto">
  <name>Task 3: Add streaming unit tests</name>
  <files>src/native/streaming.rs</files>
  <action>
Add `#[cfg(test)] mod tests` with:

1. `test_format_sse_chunk`:
   - Create StreamChunk with content "Hello"
   - Format as SSE
   - Verify output is `data: {...}\n\n` format
   - Verify JSON contains expected fields

2. `test_format_sse_done`:
   - Call format_sse_done()
   - Verify output is `data: [DONE]\n\n`

3. `test_stream_state_accumulation`:
   - Create StreamState
   - Append "Hello" then " world"
   - Verify accumulated content is "Hello world"

4. `test_create_chunk_with_metadata`:
   - Create metadata, call create_chunk_with_metadata
   - Verify chunk has correct id, model, created
   - Verify object is "chat.completion.chunk"

5. `test_format_normalized_variants`:
   - Test Delta variant formats as SSE chunk
   - Test Done variant formats as [DONE]
   - Test KeepAlive formats as SSE comment

6. `test_format_error_chunk`:
   - Create StreamError::ProviderError
   - Format as error chunk
   - Verify JSON has error object with message
  </action>
  <verify>
`cargo test native::streaming` passes with all tests green
  </verify>
  <done>
At least 6 tests covering SSE formatting, accumulation, and error handling
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check` - no errors in streaming module
2. `cargo test native::streaming` - all tests pass
3. Verify: SSE chunks end with `\n\n`
4. Verify: Done marker is exactly `data: [DONE]\n\n`
5. Verify: Error chunks include structured error JSON
</verification>

<success_criteria>
- Streaming module exists at `src/native/streaming.rs`
- SSE formatting produces valid Server-Sent Events format
- StreamState tracks metadata and accumulated content
- Error handling emits structured error chunks before close
- Unit tests verify all formatting behavior
</success_criteria>

<output>
After completion, create `.planning/phases/01-types-and-translation/01-03-SUMMARY.md`
</output>
