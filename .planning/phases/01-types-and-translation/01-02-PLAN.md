---
phase: 01-types-and-translation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/native/translate/mod.rs
  - src/native/translate/openai.rs
  - src/native/mod.rs
autonomous: true

must_haves:
  truths:
    - "Native requests translate to valid OpenAI API format"
    - "OpenAI responses translate back to unified response format"
    - "System prompts remain in messages array for OpenAI (no extraction needed)"
    - "Stop reasons map correctly between formats"
  artifacts:
    - path: "src/native/translate/mod.rs"
      provides: "Translator trait and module exports"
      contains: "pub trait MessageTranslator"
    - path: "src/native/translate/openai.rs"
      provides: "OpenAI translator implementation"
      contains: "impl MessageTranslator for OpenAITranslator"
  key_links:
    - from: "src/native/translate/openai.rs"
      to: "src/native/types.rs"
      via: "use super::super::types"
      pattern: "use.*types::"
    - from: "src/native/translate/openai.rs"
      to: "src/native/request.rs"
      via: "use super::super::request"
      pattern: "use.*request::"
---

<objective>
Implement bidirectional translation between Native API format and OpenAI format.

Purpose: Enable the Native API to communicate with OpenAI as the initial (and for v1, only) backend provider. This translator is a reference implementation that validates the type design.

Output: A `translate/` submodule with a trait-based translator pattern and complete OpenAI implementation.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-types-and-translation/01-CONTEXT.md
@.planning/phases/01-types-and-translation/01-RESEARCH.md
@.planning/phases/01-types-and-translation/01-01-SUMMARY.md
@src/native/types.rs
@src/native/request.rs
@src/native/response.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create translator trait and module structure</name>
  <files>src/native/translate/mod.rs, src/native/mod.rs</files>
  <action>
1. Create `src/native/translate/mod.rs` with:
   - `pub mod openai;`
   - `TranslationError` enum with thiserror derive:
     - `InvalidMessageFormat(String)`
     - `SystemNotFirst`
     - `MissingRequiredField(String)`
     - `SerializationError(#[from] serde_json::Error)`
   - `MessageTranslator` trait:
     ```rust
     pub trait MessageTranslator {
         /// Translate unified request to provider-specific JSON
         fn translate_request(
             &self,
             request: &ChatCompletionRequest,
         ) -> Result<serde_json::Value, TranslationError>;

         /// Translate provider response JSON to unified format
         fn translate_response(
             &self,
             response: serde_json::Value,
         ) -> Result<ChatCompletionResponse, TranslationError>;

         /// Map provider stop reason to unified format
         fn translate_stop_reason(&self, reason: &str) -> String;
     }
     ```

2. Update `src/native/mod.rs` to add `pub mod translate;`
  </action>
  <verify>
`cargo check` passes with translator trait defined
  </verify>
  <done>
TranslationError and MessageTranslator trait exist with documented methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OpenAI translator</name>
  <files>src/native/translate/openai.rs</files>
  <action>
Create `src/native/translate/openai.rs` with:

1. `OpenAITranslator` struct (unit struct, no fields needed)

2. Implement `MessageTranslator` for `OpenAITranslator`:

   `translate_request`:
   - Validate system messages are first (if any)
   - Convert messages to OpenAI format (same structure, serialize directly)
   - Include all optional parameters that are Some
   - Return as serde_json::Value
   - Note: OpenAI format matches our unified format, so minimal translation needed

   `translate_response`:
   - Deserialize response JSON to OpenAI types
   - Map to ChatCompletionResponse:
     - Copy id, object, created, model directly
     - Map choices: index, message (role, content), finish_reason
     - Map usage: prompt_tokens, completion_tokens, total_tokens
   - Handle missing optional fields gracefully

   `translate_stop_reason`:
   - OpenAI reasons: "stop", "length", "tool_calls", "content_filter", "function_call"
   - Pass through unchanged (already in unified format)

3. Add helper function `validate_message_order(messages: &[Message]) -> Result<(), TranslationError>`:
   - Iterate messages, track if non-system seen
   - Return SystemNotFirst error if system appears after non-system
  </action>
  <verify>
`cargo check` passes with OpenAITranslator implementing trait
  </verify>
  <done>
OpenAITranslator translates requests and responses bidirectionally
  </done>
</task>

<task type="auto">
  <name>Task 3: Add translator unit tests</name>
  <files>src/native/translate/openai.rs</files>
  <action>
Add `#[cfg(test)] mod tests` with:

1. `test_translate_simple_request`:
   - Create ChatCompletionRequest with 2 messages (system, user)
   - Translate to JSON
   - Verify JSON has "messages" array with correct roles

2. `test_translate_request_with_params`:
   - Request with temperature, max_tokens, top_p set
   - Verify all params present in output JSON

3. `test_system_not_first_error`:
   - Request with user message before system
   - Verify translate_request returns SystemNotFirst error

4. `test_translate_response`:
   - Create OpenAI-format response JSON
   - Translate to ChatCompletionResponse
   - Verify all fields mapped correctly

5. `test_translate_stop_reason`:
   - Test "stop", "length", "tool_calls" pass through unchanged

6. `test_empty_messages_valid`:
   - Empty messages array should translate without error
   - (Let provider reject if invalid)
  </action>
  <verify>
`cargo test translate::openai` passes with all tests green
  </verify>
  <done>
At least 6 tests covering request/response translation and validation
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check` - no errors in translate module
2. `cargo test translate::` - all tests pass
3. Verify: Request with system in middle fails translation
4. Verify: Valid request produces correct OpenAI JSON
5. Verify: OpenAI response JSON maps to unified types
</verification>

<success_criteria>
- Translate module exists at `src/native/translate/`
- MessageTranslator trait defined with three methods
- OpenAITranslator implements the trait fully
- System message order validation enforced
- Unit tests verify translation correctness
</success_criteria>

<output>
After completion, create `.planning/phases/01-types-and-translation/01-02-SUMMARY.md`
</output>
