---
phase: 03-session-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib.rs
  - src/native/request.rs
  - src/native_routes/chat.rs
  - tests/integration/native_chat.rs
autonomous: true

must_haves:
  truths:
    - "Requests with conversation_id use provider/model from stored session"
    - "First request with new conversation_id creates and stores session"
    - "Requests without conversation_id trigger fresh provider selection"
    - "Session TTL refreshes on every request (activity-based expiration)"
    - "Existing /v1/* endpoints work unchanged"
  artifacts:
    - path: "src/native/request.rs"
      provides: "conversation_id field on ChatCompletionRequest"
      contains: "conversation_id"
    - path: "src/lib.rs"
      provides: "SessionManager in AppState"
      contains: "session_manager"
    - path: "src/native_routes/chat.rs"
      provides: "Session-aware chat handler"
      contains: "session_manager"
    - path: "tests/integration/native_chat.rs"
      provides: "Session integration tests"
      contains: "conversation_id"
  key_links:
    - from: "src/native_routes/chat.rs"
      to: "src/native/session.rs"
      via: "SessionManager lookup"
      pattern: "session_manager\\.(get|create|touch)"
    - from: "src/native_routes/chat.rs"
      to: "src/native/request.rs"
      via: "conversation_id field"
      pattern: "native_request\\.conversation_id"
---

<objective>
Wire session management into the chat handler: add conversation_id to request, integrate SessionManager into AppState, and implement session-aware routing.

Purpose: Complete the session management feature by connecting all the pieces from Plan 01 into the live request flow. This enables provider stickiness within conversations.

Output: Working session management where requests with the same conversation_id consistently use the same provider/model.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-session-management/03-RESEARCH.md
@.planning/phases/03-session-management/03-01-SUMMARY.md

@src/lib.rs
@src/native/request.rs
@src/native_routes/chat.rs
@tests/integration/native_chat.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conversation_id to ChatCompletionRequest</name>
  <files>src/native/request.rs</files>
  <action>
Add `conversation_id` field to `ChatCompletionRequest` struct:

```rust
/// Conversation ID for session stickiness (optional)
/// When provided, uses the provider/model from the first request in this conversation.
/// When absent, triggers fresh provider selection each time.
#[serde(skip_serializing_if = "Option::is_none")]
pub conversation_id: Option<String>,
```

Add to the `ChatCompletionRequest` struct after the existing fields.

Add tests:
1. Test that request without conversation_id deserializes (backward compatible)
2. Test that request with conversation_id deserializes
3. Test that conversation_id is omitted from serialization when None
  </action>
  <verify>
`cargo test native::request::tests` passes with new conversation_id tests.
`cargo check` passes.
  </verify>
  <done>
ChatCompletionRequest accepts optional conversation_id field.
Existing requests without conversation_id continue to work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SessionManager to AppState</name>
  <files>src/lib.rs</files>
  <action>
1. Add import for SessionManager:
   ```rust
   use crate::native::session::SessionManager;
   ```

2. Add field to AppState struct:
   ```rust
   /// Session manager for conversation-based provider stickiness
   pub session_manager: Arc<SessionManager>,
   ```

3. Initialize in `AppState::new()`:
   ```rust
   // Initialize session manager for provider stickiness
   let session_manager = Arc::new(SessionManager::new(
       redis_cache.clone(),  // Reuse the existing redis_cache Arc
       config.session_ttl_seconds,
   ));
   ```
   Add `session_manager` to the Self { ... } return.

4. Initialize in `AppState::new_for_testing()`:
   Create SessionManager with the in_memory_cache (requires RedisCache-like interface).
   For testing, create a mock-compatible approach:
   - Create a separate redis_cache for sessions with in_memory backing
   - Or add SessionManager::new_for_testing that accepts InMemoryCache

   Simplest approach: Create test session manager using a second InMemoryCache:
   ```rust
   let session_cache = Arc::new(InMemoryCache::new(60));
   let session_redis = Arc::new(RedisCache::new_with_cache(session_cache, 60));
   let session_manager = Arc::new(SessionManager::new(session_redis, 60));
   ```

   Note: This may require adding a constructor to RedisCache that accepts a cache trait.
   Alternative: For Phase 3, just use an Arc<RedisCache> stub in tests since session
   tests will use Redis integration tests anyway.

5. Export SessionManager from lib.rs:
   ```rust
   pub use crate::native::session::SessionManager;
   ```
  </action>
  <verify>
`cargo check` passes.
`cargo test` runs without import errors.
  </verify>
  <done>
AppState contains session_manager field.
SessionManager is properly initialized in both production and test constructors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate session lookup into chat handler</name>
  <files>src/native_routes/chat.rs</files>
  <action>
Modify `native_chat_completions` handler to implement session-aware provider selection.

1. Add import for Session if needed.

2. After parsing the request and before model validation, add session handling:

```rust
// Session handling: use stored provider/model or create new session
let (provider, model) = if let Some(ref conv_id) = native_request.conversation_id {
    // Try to get existing session
    if let Some(session) = state.session_manager.get(conv_id).await.map_err(|e| {
        NativeErrorResponse::internal(format!("Session lookup failed: {}", e))
    })? {
        // Refresh TTL on activity (fire-and-forget, log errors)
        if let Err(e) = state.session_manager.touch(conv_id).await {
            warn!(conversation_id = %conv_id, error = %e, "Failed to refresh session TTL");
        }

        // Log if request model differs from session model (for debugging)
        if let Some(ref req_model) = native_request.model {
            if req_model != &session.model {
                debug!(
                    conversation_id = %conv_id,
                    session_model = %session.model,
                    request_model = %req_model,
                    "Request model differs from session model - using session model"
                );
            }
        }

        (session.provider, session.model)
    } else {
        // Session expired or never existed - create new session
        // Phase 3: model required, provider hardcoded to openai
        // Phase 4: tier routing will determine provider/model
        let model = native_request.model.clone().ok_or_else(|| {
            NativeErrorResponse::validation(
                "model field is required for new sessions. Phase 4 will enable tier-based routing.",
            )
        })?;
        let provider = "openai".to_string();

        // Store new session
        state.session_manager.create(conv_id, &provider, &model, &user.external_id)
            .await
            .map_err(|e| NativeErrorResponse::internal(format!("Session creation failed: {}", e)))?;

        info!(conversation_id = %conv_id, model = %model, "Created new session");
        (provider, model)
    }
} else {
    // No conversation_id - fresh selection each time (stateless mode)
    let model = native_request.model.clone().ok_or_else(|| {
        NativeErrorResponse::validation(
            "model field is required. Phase 4 will enable tier-based model routing.",
        )
    })?;
    ("openai".to_string(), model)
};
```

3. Remove the existing model extraction that happens after this point (lines that duplicate
   the model extraction logic).

4. Update the logging to include conversation_id when present:
   ```rust
   info!(
       model = %model,
       provider = %provider,
       stream = %is_streaming,
       messages = %native_request.messages.len(),
       external_id = %user.external_id,
       conversation_id = ?native_request.conversation_id,
       "Processing native chat completion request"
   );
   ```

5. Pass `provider` to the helper functions if needed for future multi-provider support
   (for Phase 3, it's always "openai" so this is forward-looking).
  </action>
  <verify>
`cargo check` passes.
`cargo test` passes (no regressions).
  </verify>
  <done>
Handler looks up session when conversation_id provided.
Handler creates new session for new conversation_id.
Handler uses fresh selection when no conversation_id.
Session model overrides request model when session exists.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add session integration tests</name>
  <files>tests/integration/native_chat.rs</files>
  <action>
Add integration tests to the existing native_chat.rs test file:

1. **test_session_creation_and_retrieval**:
   - Send request with `conversation_id: "test-session-1"` and `model: "gpt-4"`
   - Verify 200 response
   - Send second request with same `conversation_id` (can omit model, should work)
   - Verify 200 response and consistent behavior

2. **test_session_model_stickiness**:
   - Send request with `conversation_id: "test-session-2"` and `model: "gpt-4"`
   - Send second request with same `conversation_id` but `model: "gpt-3.5-turbo"`
   - Verify the response uses gpt-4 (session model overrides request)
   - Note: This test verifies behavior, not the actual model used (mock returns same response)

3. **test_no_conversation_id_stateless**:
   - Send two requests without conversation_id
   - Both should succeed independently (stateless)

4. **test_conversation_id_backward_compatible**:
   - Send request without conversation_id (existing behavior)
   - Verify it still works as before

Use existing test patterns from the file. Mock OpenAI responses appropriately.
  </action>
  <verify>
`cargo test --test integration native_chat` passes with new session tests.
All existing integration tests pass.
  </verify>
  <done>
Session stickiness is verified via integration tests.
Backward compatibility is confirmed.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` - No compilation errors
2. `cargo test native::request::tests` - Request tests pass (including conversation_id)
3. `cargo test --test integration native_chat` - Session integration tests pass
4. `cargo test` - Full test suite passes (no regressions)
5. Manual verification (optional): Send requests with same conversation_id, verify session behavior in logs
</verification>

<success_criteria>
- conversation_id field exists on ChatCompletionRequest
- SessionManager is available in AppState
- Handler uses session provider/model when conversation_id provided
- Handler creates session on first request with conversation_id
- Handler skips session lookup when no conversation_id
- Integration tests verify session stickiness
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-session-management/03-02-SUMMARY.md`
</output>
