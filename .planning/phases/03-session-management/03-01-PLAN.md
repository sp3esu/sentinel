---
phase: 03-session-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/native/session.rs
  - src/native/mod.rs
  - src/cache/redis.rs
  - src/config.rs
autonomous: true

must_haves:
  truths:
    - "Session struct can serialize/deserialize to JSON"
    - "SessionManager can store session in Redis with TTL"
    - "SessionManager can retrieve existing session from Redis"
    - "SessionManager can refresh TTL on session activity"
    - "SESSION_TTL_SECONDS is configurable via environment"
  artifacts:
    - path: "src/native/session.rs"
      provides: "Session struct and SessionManager service"
      exports: ["Session", "SessionManager"]
    - path: "src/cache/redis.rs"
      provides: "Session cache key function"
      contains: "fn session("
    - path: "src/config.rs"
      provides: "Session TTL configuration"
      contains: "session_ttl_seconds"
  key_links:
    - from: "src/native/session.rs"
      to: "src/cache/redis.rs"
      via: "RedisCache for storage"
      pattern: "RedisCache"
    - from: "src/native/session.rs"
      to: "src/cache/redis.rs"
      via: "cache key function"
      pattern: "keys::session"
---

<objective>
Create the session storage foundation: Session struct, SessionManager service, cache key function, and configuration.

Purpose: Establish the core session management primitives that will be integrated into the chat handler in Plan 02. Follows the existing SubscriptionCache pattern for consistency.

Output: Session module with struct and manager, extended config with session TTL, cache key helper function.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-session-management/03-RESEARCH.md

@src/cache/redis.rs
@src/config.rs
@src/native/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Session struct and SessionManager</name>
  <files>src/native/session.rs, src/native/mod.rs</files>
  <action>
Create `src/native/session.rs` with:

1. **Session struct** (serde Serialize/Deserialize):
   - `id: String` - conversation_id (the session identifier)
   - `provider: String` - provider name ("openai", "anthropic")
   - `model: String` - model identifier used for this session
   - `external_id: String` - user's external ID for debugging/cleanup
   - `created_at: i64` - Unix timestamp when session was created

2. **SessionManager struct**:
   - `cache: Arc<RedisCache>` - Redis cache reference
   - `session_ttl: u64` - TTL in seconds (from config)

3. **SessionManager methods**:
   - `new(cache: Arc<RedisCache>, session_ttl: u64) -> Self`
   - `async fn get(&self, conversation_id: &str) -> AppResult<Option<Session>>`
     - Uses `keys::session(conversation_id)` for cache key
     - Returns None if not found (not an error)
   - `async fn create(&self, conversation_id: &str, provider: &str, model: &str, external_id: &str) -> AppResult<Session>`
     - Creates Session with chrono::Utc::now().timestamp() for created_at
     - Stores with `cache.set_with_ttl()` using session_ttl
     - Returns the created session
   - `async fn touch(&self, conversation_id: &str) -> AppResult<()>`
     - Refreshes TTL using `cache.expire()`
     - Activity-based expiration (24h from last activity, not creation)

4. **Unit tests**:
   - Test Session serialization round-trip
   - Test SessionManager struct construction

Add `pub mod session;` to `src/native/mod.rs` and export Session, SessionManager.

Follow existing patterns from SubscriptionCache for error handling and logging.
  </action>
  <verify>
`cargo check` passes with no new errors.
`cargo test native::session` runs and passes.
  </verify>
  <done>
Session struct and SessionManager are defined with all CRUD operations.
Unit tests verify serialization works correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session cache key function</name>
  <files>src/cache/redis.rs</files>
  <action>
Add to the existing `keys` module in `src/cache/redis.rs`:

```rust
/// Session cache key for provider stickiness
pub fn session(conversation_id: &str) -> String {
    format!("sentinel:session:{}", conversation_id)
}
```

Add tests for the new key function following the existing test patterns:
- Test basic format: `keys::session("conv-123")` => `"sentinel:session:conv-123"`
- Test empty ID edge case
- Test special characters (UUIDs, etc.)
  </action>
  <verify>
`cargo test cache::redis::tests` passes with new key tests.
  </verify>
  <done>
Session cache key function exists and follows the sentinel:* prefix convention.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add SESSION_TTL_SECONDS to config</name>
  <files>src/config.rs</files>
  <action>
Add `session_ttl_seconds: u64` field to Config struct:
- Default: 86400 (24 hours)
- Loaded from SESSION_TTL_SECONDS environment variable
- Use same pattern as cache_ttl_seconds for parsing with context

Add to from_env():
```rust
session_ttl_seconds: env::var("SESSION_TTL_SECONDS")
    .unwrap_or_else(|_| "86400".to_string())
    .parse()
    .context("Invalid SESSION_TTL_SECONDS")?,
```

Add test verifying the default value (86400).
  </action>
  <verify>
`cargo test config::tests` passes.
`cargo check` passes.
  </verify>
  <done>
Config includes session_ttl_seconds with 24-hour default.
SESSION_TTL_SECONDS environment variable is supported.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` - No compilation errors
2. `cargo test native::session` - Session module tests pass
3. `cargo test cache::redis::tests` - Cache key tests pass (including new session key)
4. `cargo test config::tests` - Config tests pass (including session TTL)
5. `cargo test` - Full test suite passes (no regressions)
</verification>

<success_criteria>
- Session struct is serializable and has all required fields
- SessionManager has get, create, and touch methods
- Cache key follows sentinel:session:{id} pattern
- Config loads SESSION_TTL_SECONDS with 86400 default
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-session-management/03-01-SUMMARY.md`
</output>
