---
phase: 05-tool-calling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/native/types.rs
  - src/native/request.rs
  - src/native/response.rs
  - src/native/mod.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Tool definitions accepted with name, description, and parameters schema"
    - "Invalid tool schemas rejected with validation error before sending to provider"
    - "Tool names validated against alphanumeric + underscore pattern"
    - "Tool results accepted with tool_call_id, content, and optional is_error flag"
  artifacts:
    - path: "src/native/types.rs"
      provides: "ToolDefinition, ToolCall, ToolResult, ToolChoice types"
      contains: "pub struct ToolDefinition"
    - path: "src/native/request.rs"
      provides: "tools and tool_choice fields on ChatCompletionRequest"
      contains: "pub tools: Option<Vec<ToolDefinition>>"
    - path: "src/native/response.rs"
      provides: "tool_calls field on ChoiceMessage and Delta"
      contains: "pub tool_calls: Option<Vec<ToolCall>>"
    - path: "Cargo.toml"
      provides: "jsonschema dependency"
      contains: "jsonschema"
  key_links:
    - from: "src/native/request.rs"
      to: "src/native/types.rs"
      via: "ToolDefinition import"
      pattern: "use.*types::.*ToolDefinition"
    - from: "src/native/response.rs"
      to: "src/native/types.rs"
      via: "ToolCall import"
      pattern: "use.*types::.*ToolCall"
---

<objective>
Define unified tool calling types with schema validation for the Native API.

Purpose: Establish the foundation types that enable tool/function calling through the Native API. These types will be used by the translation layer (Plan 02) and streaming accumulator (Plan 03).

Output: ToolDefinition, ToolCall, ToolResult, ToolChoice types with JSON Schema validation for tool parameters.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-tool-calling/05-CONTEXT.md
@.planning/phases/05-tool-calling/05-RESEARCH.md
@src/native/types.rs
@src/native/request.rs
@src/native/response.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add jsonschema dependency and tool types</name>
  <files>Cargo.toml, src/native/types.rs</files>
  <action>
Add jsonschema = "0.29" to Cargo.toml dependencies (use a recent stable version).

In src/native/types.rs, add the following types after the existing Content/Message types:

1. **FunctionDefinition** struct:
   - `name: String` - Function name (validated: a-zA-Z0-9_ only)
   - `description: String` - Required per CONTEXT.md decision
   - `parameters: serde_json::Value` - JSON Schema for parameters

2. **ToolDefinition** struct:
   - `tool_type: String` with `#[serde(rename = "type")]` - Always "function"
   - `function: FunctionDefinition`

3. **ToolCallFunction** struct:
   - `name: String` - Function name being called
   - `arguments: serde_json::Value` - Parsed JSON object (not string, per CONTEXT.md)

4. **ToolCall** struct:
   - `id: String` - Sentinel-generated tool_call_id (format: call_{uuid})
   - `call_type: String` with `#[serde(rename = "type")]` - Always "function"
   - `function: ToolCallFunction`

5. **ToolResultContent** enum (untagged):
   - `Text(String)` - Plain string content
   - `Json(serde_json::Value)` - JSON content (serialized to string for provider)
   Add `to_string()` method for provider serialization.

6. **ToolResult** struct:
   - `tool_call_id: String` - References a ToolCall.id
   - `content: ToolResultContent` - Result content
   - `is_error: Option<bool>` - Optional flag for error results

7. **ToolChoice** enum:
   - `Auto` - serializes as "auto"
   - `None` - serializes as "none"
   - `Required` - serializes as "required"
   - `Function { name: String }` - specific function selection
   Use custom serialization to match OpenAI format.

8. Add validation function `validate_tool_name(name: &str) -> bool`:
   - Returns true if name matches `^[a-zA-Z0-9_]+$`
   - Use lazy_static or once_cell for compiled regex

9. Add validation function `validate_tool_schema(schema: &serde_json::Value) -> Result<(), String>`:
   - Use jsonschema crate to validate schema is valid JSON Schema
   - Check schema has `type: "object"` (required for function parameters)
   - Return descriptive error message on failure

Add unit tests for all new types covering:
- Serialization/deserialization roundtrips
- Tool name validation (valid and invalid cases)
- Schema validation (valid and invalid cases)
- ToolChoice serialization variants
  </action>
  <verify>
Run `cargo test native::types` - all tests pass including new tool type tests
  </verify>
  <done>
ToolDefinition, ToolCall, ToolResult, ToolChoice types exist with validation functions. Unit tests confirm serialization and validation work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tool fields to request</name>
  <files>src/native/request.rs</files>
  <action>
Update ChatCompletionRequest struct to add tool calling fields:

1. Add import: `use super::types::{..., ToolDefinition, ToolChoice};`

2. Add to ChatCompletionRequest:
   - `tools: Option<Vec<ToolDefinition>>` with `#[serde(skip_serializing_if = "Option::is_none")]`
   - `tool_choice: Option<ToolChoice>` with `#[serde(skip_serializing_if = "Option::is_none")]`

3. Update any existing request construction in tests to include the new fields as None.

4. Add tests:
   - Request with tools array deserializes correctly
   - Request with tool_choice variants deserializes correctly
   - Empty tools array accepted
   - Invalid tool name in tools array fails validation (test the validation, not serde)
   - Request serialization omits tools/tool_choice when None

Note: The actual schema validation is done at translation time (Plan 02), not at deserialization time. This keeps request parsing fast and separates concerns.
  </action>
  <verify>
Run `cargo test native::request` - all tests pass including new tool field tests
  </verify>
  <done>
ChatCompletionRequest has tools and tool_choice optional fields. Tests confirm serialization works correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tool_calls to response types</name>
  <files>src/native/response.rs, src/native/mod.rs</files>
  <action>
Update response types to include tool calls:

1. Add import in response.rs: `use super::types::ToolCall;`

2. Update **ChoiceMessage** struct:
   - Add `tool_calls: Option<Vec<ToolCall>>` with `#[serde(skip_serializing_if = "Option::is_none")]`
   - This holds tool calls when assistant decides to call tools

3. Update **Delta** struct (for streaming):
   - Add `tool_calls: Option<Vec<ToolCallDelta>>` with `#[serde(skip_serializing_if = "Option::is_none")]`

4. Add **ToolCallDelta** struct for streaming:
   - `index: u32` - Which tool call in parallel set (critical for accumulation)
   - `id: Option<String>` - Only in first delta for this index
   - `call_type: Option<String>` with `#[serde(rename = "type")]`
   - `function: Option<ToolCallFunctionDelta>`

5. Add **ToolCallFunctionDelta** struct:
   - `name: Option<String>` - Function name (only in first delta)
   - `arguments: Option<String>` - Argument string fragment (accumulated across deltas)

6. Update src/native/mod.rs to re-export new types:
   - Add ToolDefinition, ToolCall, ToolResult, ToolChoice, ToolCallDelta to pub use

7. Add tests:
   - ChoiceMessage with tool_calls serializes correctly
   - Delta with tool_calls serializes correctly
   - ToolCallDelta with partial fields works
   - Response without tool_calls omits field in JSON
  </action>
  <verify>
Run `cargo test native::response` - all tests pass including new tool_calls tests
Run `cargo build` - no compilation errors with new re-exports
  </verify>
  <done>
ChoiceMessage has tool_calls field, Delta has tool_calls with ToolCallDelta for streaming. Types re-exported from native module.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# All native module tests pass
cargo test native::

# Full test suite still passes
cargo test

# Build succeeds
cargo build
```
</verification>

<success_criteria>
- ToolDefinition, ToolCall, ToolResult, ToolChoice types defined with correct serde attributes
- validate_tool_name() rejects invalid names (special chars, empty)
- validate_tool_schema() validates JSON Schema structure
- ChatCompletionRequest accepts tools and tool_choice fields
- ChoiceMessage and Delta have tool_calls fields for responses
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-tool-calling/05-01-SUMMARY.md`
</output>
