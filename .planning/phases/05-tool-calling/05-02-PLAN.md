---
phase: 05-tool-calling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/native/translate/openai.rs
  - src/native/translate/mod.rs
  - src/native/types.rs
autonomous: true

must_haves:
  truths:
    - "Tool definitions translate to OpenAI tools format in request"
    - "tool_choice translates correctly (auto, none, required, specific function)"
    - "OpenAI tool_calls in response translate to unified format with Sentinel IDs"
    - "Tool result messages translate to OpenAI tool message format"
    - "Malformed arguments in response return error (not raw string)"
  artifacts:
    - path: "src/native/translate/openai.rs"
      provides: "Tool translation in request and response"
      contains: "translate_tools"
    - path: "src/native/translate/mod.rs"
      provides: "ToolCallIdMapping for ID translation"
      contains: "pub struct ToolCallIdMapping"
  key_links:
    - from: "src/native/translate/openai.rs"
      to: "src/native/types.rs"
      via: "ToolDefinition, ToolCall imports"
      pattern: "use.*types::.*(ToolDefinition|ToolCall)"
    - from: "OpenAITranslator::translate_request"
      to: "validate_tool_schema"
      via: "Schema validation before translation"
      pattern: "validate_tool_schema"
---

<objective>
Extend the OpenAI translator to handle tool definitions in requests and tool calls in responses.

Purpose: Enable the Native API to send tool definitions to OpenAI and receive tool call responses. This includes generating Sentinel-specific tool_call_ids and maintaining the mapping for tool result submission.

Output: Complete bidirectional tool translation in the OpenAI translator, with ID mapping for multi-turn conversations.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-tool-calling/05-CONTEXT.md
@.planning/phases/05-tool-calling/05-RESEARCH.md
@src/native/translate/openai.rs
@src/native/translate/mod.rs
@src/native/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tool translation to request</name>
  <files>src/native/translate/openai.rs, src/native/translate/mod.rs</files>
  <action>
Extend translate_request() in OpenAITranslator to handle tools:

1. Add imports in openai.rs:
   ```rust
   use crate::native::types::{validate_tool_name, validate_tool_schema, ToolDefinition, ToolChoice};
   ```

2. In translate_request(), after building the base request JSON:
   - If `request.tools` is Some and non-empty:
     - Validate each tool:
       - Check tool.function.name with validate_tool_name() -> TranslationError if invalid
       - Check tool.function.parameters with validate_tool_schema() -> TranslationError if invalid
       - Check tool.function.description is non-empty -> TranslationError if empty
     - Serialize tools array to OpenAI format (it's already OpenAI-compatible, so direct serialization works)
     - Add `tools` key to the request JSON

3. If `request.tool_choice` is Some:
   - Translate ToolChoice to OpenAI format:
     - `ToolChoice::Auto` -> `"auto"`
     - `ToolChoice::None` -> `"none"`
     - `ToolChoice::Required` -> `"required"`
     - `ToolChoice::Function { name }` -> `{"type": "function", "function": {"name": name}}`
   - Add `tool_choice` key to the request JSON

4. Add TranslationError variant for tool validation:
   ```rust
   InvalidToolDefinition(String),
   ```

5. Add tests:
   - Request with valid tools translates correctly
   - Request with invalid tool name returns TranslationError
   - Request with invalid tool schema returns TranslationError
   - Request with empty description returns TranslationError
   - All tool_choice variants translate correctly
   - Empty tools array is valid (no tools key added, or empty array - match OpenAI behavior)
  </action>
  <verify>
Run `cargo test native::translate::openai` - all tests pass
  </verify>
  <done>
translate_request() validates and includes tools and tool_choice in OpenAI request format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tool call translation in response</name>
  <files>src/native/translate/openai.rs, src/native/translate/mod.rs</files>
  <action>
Extend translate_response() to handle tool_calls in assistant messages:

1. Add ToolCallIdMapping struct in translate/mod.rs:
   ```rust
   use std::collections::HashMap;
   use uuid::Uuid;

   /// Maps between Sentinel and provider tool call IDs
   #[derive(Debug, Default, Clone)]
   pub struct ToolCallIdMapping {
       sentinel_to_provider: HashMap<String, String>,
       provider_to_sentinel: HashMap<String, String>,
   }

   impl ToolCallIdMapping {
       pub fn new() -> Self { Self::default() }

       /// Generate a Sentinel ID and map to provider ID
       pub fn generate_sentinel_id(&mut self, provider_id: &str) -> String {
           let sentinel_id = format!("call_{}", Uuid::new_v4());
           self.sentinel_to_provider.insert(sentinel_id.clone(), provider_id.to_string());
           self.provider_to_sentinel.insert(provider_id.to_string(), sentinel_id.clone());
           sentinel_id
       }

       /// Get provider ID from Sentinel ID (for result submission)
       pub fn get_provider_id(&self, sentinel_id: &str) -> Option<&String> {
           self.sentinel_to_provider.get(sentinel_id)
       }

       /// Get Sentinel ID from provider ID (for response translation)
       pub fn get_sentinel_id(&self, provider_id: &str) -> Option<&String> {
           self.provider_to_sentinel.get(provider_id)
       }
   }
   ```

2. Update MessageTranslator trait to return ID mapping with response:
   ```rust
   fn translate_response(
       &self,
       response: serde_json::Value,
   ) -> Result<(ChatCompletionResponse, ToolCallIdMapping), TranslationError>;
   ```

3. In OpenAITranslator::translate_response(), when parsing choice.message:
   - Check for `tool_calls` array in message JSON
   - For each tool_call:
     - Extract `id` (provider ID)
     - Generate Sentinel ID using mapping.generate_sentinel_id(provider_id)
     - Extract `function.name`
     - Extract `function.arguments` (JSON string from OpenAI)
     - Parse arguments as JSON -> if malformed, return TranslationError::MalformedArguments
     - Create ToolCall with Sentinel ID and parsed arguments
   - Add tool_calls to ChoiceMessage
   - Return the populated ToolCallIdMapping with the response

4. Update translate_stop_reason to handle "tool_calls" finish_reason (already passes through)

5. Update all callers of translate_response to handle the new return type (check native_routes/chat.rs usage - may need updates there in Plan 03 or a quick fix here)

6. Add tests:
   - Response with tool_calls translates correctly
   - Provider ID maps to new Sentinel ID
   - Multiple parallel tool_calls each get unique Sentinel IDs
   - Malformed arguments (not valid JSON) returns error
   - Arguments parsed as JSON object (not string)
   - Response without tool_calls returns empty mapping
   - finish_reason "tool_calls" passes through
  </action>
  <verify>
Run `cargo test native::translate` - all tests pass
Run `cargo build` - compiles (callers may need updates)
  </verify>
  <done>
translate_response() extracts tool_calls with Sentinel ID generation and argument parsing. ToolCallIdMapping tracks ID translation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tool result message handling</name>
  <files>src/native/translate/openai.rs, src/native/types.rs</files>
  <action>
Handle tool result messages in request translation:

1. Tool results in Native API come as messages with role: Tool. Update Message struct if needed to handle tool results, OR create a separate path in translation.

   Per CONTEXT.md, tool results use a unified format:
   ```json
   {
     "tool_call_id": "call_xxx",
     "content": "result string or JSON",
     "is_error": false  // optional
   }
   ```

   This needs to translate to OpenAI's tool message format:
   ```json
   {
     "role": "tool",
     "tool_call_id": "call_xxx",
     "name": "function_name",  // required by OpenAI but not in our unified format
     "content": "string"
   }
   ```

2. Challenge: OpenAI requires `name` field in tool messages, but our unified format doesn't include it. Two options:
   - a) Add `name` to ToolResult in types.rs (simplest, explicit)
   - b) Look up name from previous tool_calls in conversation history

   Choose option (a) - add optional `name: Option<String>` to ToolResult. If not provided, translation returns error.

3. In translate_request(), when processing messages:
   - If message has role: Tool:
     - Check message has tool_call_id -> error if missing
     - Translate content (string or JSON) to string format for OpenAI
     - If is_error is true, optionally prefix content or handle per OpenAI conventions
     - Create OpenAI tool message with role, tool_call_id, name, content

4. Update Message struct in types.rs:
   - `tool_call_id` already exists
   - Add `name: Option<String>` with skip_serializing_if for tool message function name
   - Content for tool messages should be the result

5. Add tests:
   - Tool message translates to OpenAI tool format
   - Tool message with JSON content stringifies correctly
   - Tool message with is_error flag works
   - Tool message missing name returns error for OpenAI translation
   - Tool message missing tool_call_id returns error
  </action>
  <verify>
Run `cargo test native::translate::openai` - all tests pass
Run `cargo test native::types` - all tests pass
  </verify>
  <done>
Tool result messages (role: Tool) translate correctly to OpenAI's tool message format. Message struct supports tool result fields.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# All translate module tests pass
cargo test native::translate

# Type tests pass
cargo test native::types

# Build succeeds (even if chat handler needs updates)
cargo build
```
</verification>

<success_criteria>
- Tool definitions in request validate and translate to OpenAI format
- tool_choice variants translate correctly (auto, none, required, specific)
- Tool calls in response have Sentinel-generated IDs (call_{uuid} format)
- Arguments parsed as JSON object, malformed arguments return error
- ToolCallIdMapping tracks bidirectional ID translation
- Tool result messages translate to OpenAI tool format
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-tool-calling/05-02-SUMMARY.md`
</output>
