---
phase: 05-tool-calling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/native/translate/openai.rs
  - src/native/translate/mod.rs
autonomous: true

must_haves:
  truths:
    - "Tool definitions translate to OpenAI tools format in request"
    - "tool_choice translates correctly (auto, none, required, specific function)"
    - "OpenAI tool_calls in response translate to unified format with Sentinel IDs"
    - "Tool result messages translate to OpenAI tool message format"
    - "Malformed arguments in response return error (not raw string)"
  artifacts:
    - path: "src/native/translate/openai.rs"
      provides: "Tool translation in request and response"
      contains: "translate_tools"
    - path: "src/native/translate/mod.rs"
      provides: "ToolCallIdMapping for ID translation"
      contains: "pub struct ToolCallIdMapping"
  key_links:
    - from: "src/native/translate/openai.rs"
      to: "src/native/types.rs"
      via: "ToolDefinition, ToolCall imports"
      pattern: "use.*types::.*(ToolDefinition|ToolCall)"
    - from: "OpenAITranslator::translate_request"
      to: "validate_tool_schema"
      via: "Schema validation before translation"
      pattern: "validate_tool_schema"
    - from: "tool result translation"
      to: "conversation history"
      via: "Function name lookup by tool_call_id"
      pattern: "find.*tool_call_id|lookup.*name"
---

<objective>
Extend the OpenAI translator to handle tool definitions in requests and tool calls in responses.

Purpose: Enable the Native API to send tool definitions to OpenAI and receive tool call responses. This includes generating Sentinel-specific tool_call_ids and maintaining the mapping for tool result submission.

Output: Complete bidirectional tool translation in the OpenAI translator, with ID mapping for multi-turn conversations.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-tool-calling/05-CONTEXT.md
@.planning/phases/05-tool-calling/05-RESEARCH.md
@src/native/translate/openai.rs
@src/native/translate/mod.rs
@src/native/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tool translation to request</name>
  <files>src/native/translate/openai.rs, src/native/translate/mod.rs</files>
  <action>
Extend translate_request() in OpenAITranslator to handle tools:

1. Add imports in openai.rs:
   ```rust
   use crate::native::types::{validate_tool_name, validate_tool_schema, ToolDefinition, ToolChoice};
   ```

2. In translate_request(), after building the base request JSON:
   - If `request.tools` is Some and non-empty:
     - Validate each tool:
       - Check tool.function.name with validate_tool_name() -> TranslationError if invalid
       - Check tool.function.parameters with validate_tool_schema() -> TranslationError if invalid
       - Check tool.function.description is non-empty -> TranslationError if empty
     - Serialize tools array to OpenAI format (it's already OpenAI-compatible, so direct serialization works)
     - Add `tools` key to the request JSON

3. If `request.tool_choice` is Some:
   - Translate ToolChoice to OpenAI format:
     - `ToolChoice::Auto` -> `"auto"`
     - `ToolChoice::None` -> `"none"`
     - `ToolChoice::Required` -> `"required"`
     - `ToolChoice::Function { name }` -> `{"type": "function", "function": {"name": name}}`
   - Add `tool_choice` key to the request JSON

4. Add TranslationError variant for tool validation:
   ```rust
   InvalidToolDefinition(String),
   ```

5. Add tests:
   - Request with valid tools translates correctly
   - Request with invalid tool name returns TranslationError
   - Request with invalid tool schema returns TranslationError
   - Request with empty description returns TranslationError
   - All tool_choice variants translate correctly
   - Empty tools array is valid (no tools key added, or empty array - match OpenAI behavior)
  </action>
  <verify>
Run `cargo test native::translate::openai` - all tests pass
  </verify>
  <done>
translate_request() validates and includes tools and tool_choice in OpenAI request format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tool call translation in response</name>
  <files>src/native/translate/openai.rs, src/native/translate/mod.rs</files>
  <action>
Extend translate_response() to handle tool_calls in assistant messages:

1. Add ToolCallIdMapping struct in translate/mod.rs:
   ```rust
   use std::collections::HashMap;
   use uuid::Uuid;

   /// Maps between Sentinel and provider tool call IDs
   #[derive(Debug, Default, Clone)]
   pub struct ToolCallIdMapping {
       sentinel_to_provider: HashMap<String, String>,
       provider_to_sentinel: HashMap<String, String>,
   }

   impl ToolCallIdMapping {
       pub fn new() -> Self { Self::default() }

       /// Generate a Sentinel ID and map to provider ID
       pub fn generate_sentinel_id(&mut self, provider_id: &str) -> String {
           let sentinel_id = format!("call_{}", Uuid::new_v4());
           self.sentinel_to_provider.insert(sentinel_id.clone(), provider_id.to_string());
           self.provider_to_sentinel.insert(provider_id.to_string(), sentinel_id.clone());
           sentinel_id
       }

       /// Get provider ID from Sentinel ID (for result submission)
       pub fn get_provider_id(&self, sentinel_id: &str) -> Option<&String> {
           self.sentinel_to_provider.get(sentinel_id)
       }

       /// Get Sentinel ID from provider ID (for response translation)
       pub fn get_sentinel_id(&self, provider_id: &str) -> Option<&String> {
           self.provider_to_sentinel.get(provider_id)
       }
   }
   ```

2. Update MessageTranslator trait to return ID mapping with response:
   ```rust
   fn translate_response(
       &self,
       response: serde_json::Value,
   ) -> Result<(ChatCompletionResponse, ToolCallIdMapping), TranslationError>;
   ```

3. In OpenAITranslator::translate_response(), when parsing choice.message:
   - Check for `tool_calls` array in message JSON
   - For each tool_call:
     - Extract `id` (provider ID)
     - Generate Sentinel ID using mapping.generate_sentinel_id(provider_id)
     - Extract `function.name`
     - Extract `function.arguments` (JSON string from OpenAI)
     - Parse arguments as JSON -> if malformed, return TranslationError::MalformedArguments
     - Create ToolCall with Sentinel ID and parsed arguments
   - Add tool_calls to ChoiceMessage
   - Return the populated ToolCallIdMapping with the response

4. Update translate_stop_reason to handle "tool_calls" finish_reason (already passes through)

5. Update all callers of translate_response to handle the new return type (check native_routes/chat.rs usage - may need updates there in Plan 03 or a quick fix here)

6. Add tests:
   - Response with tool_calls translates correctly
   - Provider ID maps to new Sentinel ID
   - Multiple parallel tool_calls each get unique Sentinel IDs
   - Malformed arguments (not valid JSON) returns error
   - Arguments parsed as JSON object (not string)
   - Response without tool_calls returns empty mapping
   - finish_reason "tool_calls" passes through
  </action>
  <verify>
Run `cargo test native::translate` - all tests pass
Run `cargo build` - compiles (callers may need updates)
  </verify>
  <done>
translate_response() extracts tool_calls with Sentinel ID generation and argument parsing. ToolCallIdMapping tracks ID translation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tool result translation with history lookup</name>
  <files>src/native/translate/openai.rs</files>
  <action>
Handle tool result messages in request translation. Per locked decision, ToolResult has only (tool_call_id, content, is_error) - NO name field. Function name is obtained from conversation history.

**Approach:** When translating a tool result message, search the preceding messages for an assistant message containing tool_calls with a matching tool_call_id, then extract the function name from that tool_call.

1. Add helper function to find function name from history:
   ```rust
   /// Find function name for a tool_call_id by searching conversation history.
   /// Searches backwards through messages for an assistant message with matching
   /// tool_call_id in its tool_calls array.
   fn find_function_name_for_tool_call(
       messages: &[Message],
       tool_call_id: &str,
       current_index: usize,
   ) -> Option<String> {
       // Search backwards from current_index
       for i in (0..current_index).rev() {
           let msg = &messages[i];
           if msg.role == Role::Assistant {
               if let Some(ref tool_calls) = msg.tool_calls {
                   for tc in tool_calls {
                       if tc.id == tool_call_id {
                           return Some(tc.function.name.clone());
                       }
                   }
               }
           }
       }
       None
   }
   ```

2. In translate_request(), when processing messages with role: Tool:
   - Get tool_call_id from message -> error if missing
   - Call find_function_name_for_tool_call() to get function name from history
   - If function name not found, return TranslationError::MissingToolCallInHistory
   - Translate content (string or JSON) to string format for OpenAI
   - If is_error is true, optionally prefix content or handle per OpenAI conventions
   - Create OpenAI tool message with role, tool_call_id, name (from history lookup), content

3. Add TranslationError variant:
   ```rust
   MissingToolCallInHistory(String), // "No tool call found for tool_call_id: {id}"
   ```

4. Add tests:
   - Tool message translates correctly when matching tool_call found in history
   - Tool message with JSON content stringifies correctly
   - Tool message with is_error flag works
   - Tool message with tool_call_id not found in history returns MissingToolCallInHistory error
   - Tool message missing tool_call_id returns error
   - Multiple tool results in conversation each find correct function names
  </action>
  <verify>
Run `cargo test native::translate::openai` - all tests pass
  </verify>
  <done>
Tool result messages (role: Tool) translate to OpenAI format by looking up function name from conversation history. No name field added to ToolResult type.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# All translate module tests pass
cargo test native::translate

# Type tests pass
cargo test native::types

# Build succeeds (even if chat handler needs updates)
cargo build
```
</verification>

<success_criteria>
- Tool definitions in request validate and translate to OpenAI format
- tool_choice variants translate correctly (auto, none, required, specific)
- Tool calls in response have Sentinel-generated IDs (call_{uuid} format)
- Arguments parsed as JSON object, malformed arguments return error
- ToolCallIdMapping tracks bidirectional ID translation
- Tool result translation looks up function name from conversation history
- ToolResult struct unchanged (tool_call_id, content, is_error only - no name field)
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-tool-calling/05-02-SUMMARY.md`
</output>
